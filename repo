#!/bin/bash -e
#
# Build packages and export repository for metapackages.
#

RSYNC_SSH_TARGET="do:html/repo/"

BASE_DIR="$PWD"
KEYS_DIR="$BASE_DIR/keys"
PACKAGES_DIR="$BASE_DIR/packages"
REPO_DIR="$BASE_DIR/repos/ubuntu"

# variables used by reprepro
export REPREPRO_CONFIG_DIR="$BASE_DIR/conf"
export REPREPRO_BASE_DIR
export GNUPGHOME

setup_gpg() {
    GNUPGHOME=$(mktemp -d)
    gpg --import < "$KEYS_DIR/seckey.gpg"
}


cleanup_gpg() {
    rm -rf "$GNUPGHOME"
}


setup_repo() {
    REPREPRO_BASE_DIR=$(mktemp -d)
    rm -rf "$REPO_DIR"
    mkdir -p "$REPO_DIR"
    cp "$KEYS_DIR/pubkey.gpg" "$REPO_DIR"
}


build_package() {
    local package="$1"
    local control_file="$PACKAGES_DIR/$package"
    if [ ! -f "$control_file" ]; then
        echo "Skipping unknown package $package"
        return 1
    fi
    equivs-build "$control_file"
}


import_package() {
    local package="$1"
    local changes="${package}*.changes"
    local opts="--outdir $REPO_DIR -VVV"
    # shellcheck disable=SC2086
    reprepro $opts include unstable $changes
    rm "${package}"*
}


cleanup_repo() {
    rm -rf "$REPREPRO_BASE_DIR"
}


repo_build() {
    local packages="$*"
    if [ $# -eq 0 ]; then
        packages="$(cd "$PACKAGES_DIR"; ls)"
    fi

    setup_gpg
    setup_repo

    for package in $packages; do
        build_package "$package" || continue
        import_package "$package"
    done

    cleanup_gpg
    cleanup_repo
}

repo_copy() {
    rsync -av --delete "$REPO_DIR" "$RSYNC_SSH_TARGET"
}

repo_list() {
    local pool_dir="$REPO_DIR/pool"
    [  -d "$pool_dir" ] || return
    find "$pool_dir" -type f | sed 's,.*/\([^_]\+\)_\([^_]\+\).*,\1 \2,'
}

usage() {
    echo "Usage: $0 {build,copy,list}" >&2
    exit 1
}

cmd="$1"
if [ -z "$cmd" ]; then
    usage
fi

shift 1
case $cmd in
    build | copy | list)
        "repo_${cmd}" "$@"
        ;;
    *)
        usage
        ;;
esac
